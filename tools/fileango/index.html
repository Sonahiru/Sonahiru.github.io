<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ファイル パスワード暗号化</title>
  <style>
    body{font-family:system-ui, -apple-system, sans-serif; background:#0f172a; color:#e2e8f0; margin:0; padding:24px}
    .card{max-width:820px; margin:0 auto; background:#1e293b; padding:24px; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.3)}
    h1{margin-top:0; font-size:24px}
    input, button{width:100%; margin-top:12px; padding:12px; border-radius:10px; border:none; font-size:14px}
    input[type="file"], input[type="password"]{background:#334155; color:#e2e8f0}
    button{background:#38bdf8; color:#0f172a; font-weight:700; cursor:pointer}
    button.secondary{background:#475569; color:#e2e8f0}
    .note{font-size:12px; opacity:.7; margin-top:12px}
    .viewer{margin-top:16px; background:#0b1220; padding:12px; border-radius:10px; overflow:auto; max-height:420px}
    img, video{max-width:100%; border-radius:8px}
    pre{white-space:pre-wrap; word-wrap:break-word}
  </style>
</head>
<body>
  <div class="card">
    <h1>ファイルをパスワードで暗号化 / 復号 / 閲覧</h1>

    <input type="file" id="fileInput" multiple />
    <input type="password" id="passwordInput" placeholder="パスワード" />

    <button onclick="encryptFiles()">一括暗号化してダウンロード</button>
    <button class="secondary" onclick="decryptFiles()">一括復号してダウンロード</button>
    <button class="secondary" onclick="viewFile()">復号して閲覧</button>

    <div class="note">
      ・すべてブラウザ内で処理（アップロードなし）<br/>
      ・AES-GCM + PBKDF2 / 元ファイルの種類も保存
    </div>

    <div class="viewer" id="fileViewer">ここに復号内容が表示される</div>
  </div>

<script>
async function getKey(password, salt) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    {name: "PBKDF2"},
    false,
    ["deriveKey"]
  );

  return crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: salt,
      iterations: 250000,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

// [salt16][iv12][metaLen4][metaJSON][cipher]
function packEncrypted(salt, iv, metaObj, cipherBuf){
  const metaStr = JSON.stringify(metaObj);
  const metaBytes = new TextEncoder().encode(metaStr);
  const metaLen = new Uint32Array([metaBytes.length]);

  const result = new Uint8Array(16 + 12 + 4 + metaBytes.length + cipherBuf.byteLength);
  result.set(salt, 0);
  result.set(iv, 16);
  result.set(new Uint8Array(metaLen.buffer), 28);
  result.set(metaBytes, 32);
  result.set(new Uint8Array(cipherBuf), 32 + metaBytes.length);
  return result;
}

function unpackEncrypted(buffer){
  const salt = buffer.slice(0,16);
  const iv = buffer.slice(16,28);
  const metaLen = new Uint32Array(buffer.slice(28,32).buffer)[0];
  const metaStart = 32;
  const metaEnd = metaStart + metaLen;
  const metaJSON = new TextDecoder().decode(buffer.slice(metaStart, metaEnd));
  const meta = JSON.parse(metaJSON);
  const data = buffer.slice(metaEnd);
  return {salt, iv, meta, data};
}

async function encryptFiles() {
  const files = document.getElementById("fileInput").files;
  const password = document.getElementById("passwordInput").value;
  if (!files.length || !password) { alert("ファイルとパスワードを入力して"); return; }

  for (const file of files) {
    const data = await file.arrayBuffer();
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await getKey(password, salt);

    const encrypted = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, data);

    const packed = packEncrypted(salt, iv, {
      name: file.name,
      type: file.type || "application/octet-stream"
    }, encrypted);

    downloadBlob(new Blob([packed]), file.name + ".enc");
  }
}

async function decryptFiles() {
  const files = document.getElementById("fileInput").files;
  const password = document.getElementById("passwordInput").value;
  if (!files.length || !password) { alert("ファイルとパスワードを入力して"); return; }

  for (const file of files) {
    try {
      const buffer = new Uint8Array(await file.arrayBuffer());
      const {salt, iv, meta, data} = unpackEncrypted(buffer);

      const key = await getKey(password, salt);
      const decrypted = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data);

      downloadBlob(new Blob([decrypted], {type: meta.type}), meta.name);
    } catch(e){
      alert(file.name + " の復号に失敗（パスワード違いの可能性）");
    }
  }
}

async function viewFile() {
  const file = document.getElementById("fileInput").files[0];
  const password = document.getElementById("passwordInput").value;
  const viewer = document.getElementById("fileViewer");
  viewer.innerHTML = "";

  if (!file || !password) { alert("ファイルとパスワードを入力して"); return; }

  try {
    const buffer = new Uint8Array(await file.arrayBuffer());
    const {salt, iv, meta, data} = unpackEncrypted(buffer);

    const key = await getKey(password, salt);
    const decrypted = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data);

    const blob = new Blob([decrypted], {type: meta.type});
    const url = URL.createObjectURL(blob);

    if (meta.type.startsWith("image/")) {
      const img = document.createElement("img");
      img.src = url;
      viewer.appendChild(img);
    }
    else if (meta.type.startsWith("video/")) {
      const video = document.createElement("video");
      video.src = url;
      video.controls = true;
      viewer.appendChild(video);
    }
    else if (meta.type.startsWith("text/")) {
      const text = await blob.text();
      const pre = document.createElement("pre");
      pre.textContent = text;
      viewer.appendChild(pre);
    }
    else {
      const msg = document.createElement("div");
      msg.textContent = "この形式は閲覧プレビュー非対応。復号ダウンロードして開いて。";
      viewer.appendChild(msg);
    }
  } catch(e){
    alert("復号に失敗（パスワード違いの可能性）");
  }
}
</script>
</body>
</html>
