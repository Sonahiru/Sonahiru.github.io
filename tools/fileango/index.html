<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ファイル パスワード暗号化</title>
  <style>
    body{font-family:system-ui, -apple-system, sans-serif; background:#0f172a; color:#e2e8f0; margin:0; padding:24px}
    .card{max-width:820px; margin:0 auto; background:#1e293b; padding:24px; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.3)}
    h1{margin-top:0; font-size:24px}
    input, button{width:100%; margin-top:12px; padding:12px; border-radius:10px; border:none; font-size:14px; box-sizing: border-box;}
    input[type="file"], input[type="password"]{background:#334155; color:#e2e8f0}
    
    /* ボタンの色設定 */
    button{background:#38bdf8; color:#0f172a; font-weight:700; cursor:pointer; transition: opacity 0.2s;}
    button:hover{opacity: 0.9;}
    button.secondary{background:#475569; color:#e2e8f0}
    button.action-btn{background:#10b981; color:#0f172a;}
    
    .note{font-size:12px; opacity:.7; margin-top:12px}

    /* ビューワーエリアのスタイル */
    .viewer-container {
      margin-top: 16px;
      border-radius: 10px;
      overflow: hidden;
      background:#0b1220;
      border: 1px solid #334155;
      display: flex;
      flex-direction: column;
    }

    /* 全画面操作用のバー */
    .viewer-toolbar {
      padding: 8px 12px;
      background: #1e293b;
      border-bottom: 1px solid #334155;
      display: flex;
      justify-content: flex-end;
    }
    .viewer-toolbar button {
      width: auto;
      margin: 0;
      padding: 6px 12px;
      font-size: 12px;
    }

    .viewer-content {
      padding: 12px;
      overflow:auto; 
      max-height:420px;
      min-height: 100px;
    }

    /* 全画面モード時のスタイル */
    .viewer-container.fullscreen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100vw; height: 100vh;
      z-index: 9999;
      border-radius: 0;
      margin: 0;
    }
    .viewer-container.fullscreen .viewer-content {
      max-height: none; /* 高さ制限解除 */
      flex: 1; /* 残りの高さを埋める */
    }

    /* 個別ファイルの表示ブロック */
    .file-block {
      background: #1e293b;
      padding: 16px;
      margin-bottom: 16px;
      border-radius: 8px;
      border: 1px solid #334155;
    }
    .file-title {
      font-size: 14px;
      font-weight: bold;
      color: #94a3b8;
      margin-bottom: 8px;
      border-bottom: 1px solid #334155;
      padding-bottom: 4px;
    }

    img, video{max-width:100%; border-radius:8px; display: block;}
    pre{white-space:pre-wrap; word-wrap:break-word; background: #0f172a; padding: 10px; border-radius: 4px; font-family: monospace;}
  </style>
</head>
<body>
  <div class="card">
    <h1>ファイルをパスワードで暗号化 / 復号 / 閲覧</h1>

    <input type="file" id="fileInput" multiple />
    <input type="password" id="passwordInput" placeholder="パスワード" />

    <button onclick="encryptFiles()">一括暗号化してダウンロード</button>
    <button class="secondary" onclick="decryptFiles()">一括復号してダウンロード</button>
    <button class="action-btn" onclick="viewFiles()">一括復号して閲覧</button>

    <div class="note">
      ・すべてブラウザ内で処理（アップロードなし）<br/>
      ・AES-GCM + PBKDF2 / 元ファイルの種類も保存
    </div>

    <div class="viewer-container" id="viewerContainer">
      <div class="viewer-toolbar">
        <button class="secondary" onclick="toggleFullScreen()" id="fsBtn">⛶ 全画面表示</button>
      </div>
      <div class="viewer-content" id="fileViewer">
        <div style="color:#64748b; text-align:center; padding:20px;">ここに復号内容が表示されます</div>
      </div>
    </div>
  </div>

<script>
async function getKey(password, salt) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    {name: "PBKDF2"},
    false,
    ["deriveKey"]
  );

  return crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: salt,
      iterations: 250000,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

// [salt16][iv12][metaLen4][metaJSON][cipher]
function packEncrypted(salt, iv, metaObj, cipherBuf){
  const metaStr = JSON.stringify(metaObj);
  const metaBytes = new TextEncoder().encode(metaStr);
  const metaLen = new Uint32Array([metaBytes.length]);

  const result = new Uint8Array(16 + 12 + 4 + metaBytes.length + cipherBuf.byteLength);
  result.set(salt, 0);
  result.set(iv, 16);
  result.set(new Uint8Array(metaLen.buffer), 28);
  result.set(metaBytes, 32);
  result.set(new Uint8Array(cipherBuf), 32 + metaBytes.length);
  return result;
}

function unpackEncrypted(buffer){
  const salt = buffer.slice(0,16);
  const iv = buffer.slice(16,28);
  const metaLen = new Uint32Array(buffer.slice(28,32).buffer)[0];
  const metaStart = 32;
  const metaEnd = metaStart + metaLen;
  const metaJSON = new TextDecoder().decode(buffer.slice(metaStart, metaEnd));
  const meta = JSON.parse(metaJSON);
  const data = buffer.slice(metaEnd);
  return {salt, iv, meta, data};
}

async function encryptFiles() {
  const files = document.getElementById("fileInput").files;
  const password = document.getElementById("passwordInput").value;
  if (!files.length || !password) { alert("ファイルとパスワードを入力して"); return; }

  for (const file of files) {
    const data = await file.arrayBuffer();
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await getKey(password, salt);

    const encrypted = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, data);

    const packed = packEncrypted(salt, iv, {
      name: file.name,
      type: file.type || "application/octet-stream"
    }, encrypted);

    downloadBlob(new Blob([packed]), file.name + ".enc");
  }
}

async function decryptFiles() {
  const files = document.getElementById("fileInput").files;
  const password = document.getElementById("passwordInput").value;
  if (!files.length || !password) { alert("ファイルとパスワードを入力して"); return; }

  for (const file of files) {
    try {
      const buffer = new Uint8Array(await file.arrayBuffer());
      const {salt, iv, meta, data} = unpackEncrypted(buffer);

      const key = await getKey(password, salt);
      const decrypted = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data);

      downloadBlob(new Blob([decrypted], {type: meta.type}), meta.name);
    } catch(e){
      alert(file.name + " の復号に失敗（パスワード違いの可能性）");
    }
  }
}

// === 変更点: 複数ファイル閲覧とDOM生成ロジックの強化 ===
async function viewFiles() {
  const files = document.getElementById("fileInput").files;
  const password = document.getElementById("passwordInput").value;
  const viewer = document.getElementById("fileViewer");
  
  // ビューワーをリセット
  viewer.innerHTML = "";

  if (!files.length || !password) { alert("ファイルとパスワードを入力して"); return; }

  let successCount = 0;

  // ループですべてのファイルを処理
  for (const file of files) {
    try {
      const buffer = new Uint8Array(await file.arrayBuffer());
      const {salt, iv, meta, data} = unpackEncrypted(buffer);

      const key = await getKey(password, salt);
      const decrypted = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data);

      const blob = new Blob([decrypted], {type: meta.type});
      const url = URL.createObjectURL(blob);

      // ファイルごとにブロックを作成
      const block = document.createElement("div");
      block.className = "file-block";
      
      const title = document.createElement("div");
      title.className = "file-title";
      title.textContent = meta.name; // 元のファイル名を表示
      block.appendChild(title);

      if (meta.type.startsWith("image/")) {
        const img = document.createElement("img");
        img.src = url;
        block.appendChild(img);
      }
      else if (meta.type.startsWith("video/")) {
        const video = document.createElement("video");
        video.src = url;
        video.controls = true;
        block.appendChild(video);
      }
      else if (meta.type.startsWith("text/")) {
        const text = await blob.text();
        const pre = document.createElement("pre");
        pre.textContent = text;
        block.appendChild(pre);
      }
      else {
        const msg = document.createElement("div");
        msg.textContent = "プレビュー非対応形式 (" + meta.type + ")";
        block.appendChild(msg);
      }

      viewer.appendChild(block);
      successCount++;

    } catch(e){
      // 失敗したファイルのエラー表示
      console.error(e);
      const errorBlock = document.createElement("div");
      errorBlock.className = "file-block";
      errorBlock.style.borderColor = "#ef4444";
      errorBlock.innerHTML = `<div class="file-title" style="color:#ef4444">${file.name}</div><div>復号失敗（パスワード違いまたは破損）</div>`;
      viewer.appendChild(errorBlock);
    }
  }

  if (successCount === 0 && files.length > 0) {
    alert("すべてのファイルの復号に失敗しました。パスワードを確認してください。");
  }
}

// === 追加: 全画面切り替え機能 ===
function toggleFullScreen() {
  const container = document.getElementById("viewerContainer");
  const btn = document.getElementById("fsBtn");
  
  // クラスの付け外しで全画面を制御
  container.classList.toggle("fullscreen");
  
  if (container.classList.contains("fullscreen")) {
    btn.textContent = "× 全画面解除";
    btn.style.background = "#ef4444"; // 解除ボタンは赤系にするなど
    btn.style.color = "#fff";
  } else {
    btn.textContent = "⛶ 全画面表示";
    btn.style.background = "#475569"; // 元の色に戻す
    btn.style.color = "#e2e8f0";
  }
}
</script>
</body>
</html>
